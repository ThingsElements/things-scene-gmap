<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../google-apis/google-maps-api.html">
<link rel="import" href="../google-map/google-map.html">

<link rel="import" href="../things-scene-viewer/things-scene-viewer.html">
<link rel="import" href="../things-scene-viewer/things-scene-layer.html">
<link rel="import" href="../things-scene-viewer/things-scene-handler.html">

<!-- <link rel="import" href="./elements.html"> -->

<!--
An element providing a solution to no problem in particular.

Example:

    <things-gmap-scene-overlay></things-gmap-scene-overlay>

Example:

    <things-gmap-scene-overlay>
      <h2>Hello things-gmap-scene-overlay</h2>
    </things-gmap-scene-overlay>

@demo demo/index-gmap-scene-overlay.html
@hero hero.svg
-->

<dom-module id="things-gmap-scene-overlay">
  <template>
    <style>
      :host {
        display: block;
        @apply(--things-gmap-scene-overlay)
      }
      #map {
        @apply(--things-gmap-scene-overlay-map)
      }

      things-scene-viewer {
        position: absolute;
        top: 0;
        left: 0;
        /*pointerEvents: none;*/
      }
    </style>

    <content></content>

    <google-maps-api id="api" version="3.exp"></google-maps-api>

    <google-map id="map"
                latitude="[[center.lat]]"
                longitude="[[center.lng]]"
                map-type="roadmap"
                map="{{map}}"
                zoom="{{zoom}}"
                min-zoom="2">
    </google-map>

    <things-scene-viewer id="scene"
                         mode="{{mode}}"
                         scene="{{scene}}"
                         model="[[model]]">
      <things-scene-layer type="selection-layer"></things-scene-layer>
      <things-scene-layer type="modeling-layer"></things-scene-layer>

      <things-scene-handler type="text-editor"></things-scene-handler>
      <things-scene-handler type="move-handler"></things-scene-handler>
      <things-scene-handler type="gmap-shift"></things-scene-handler>
    </things-scene-viewer>

  </template>

  <script src="./things-scene-gmap.js"></script>

  <script>

    var GmapSceneOverlay;
    var CSS_TRANSFORM = (function() {
      var div = document.createElement('div');
      var transformProps = [
        'transform',
        'WebkitTransform',
        'MozTransform',
        'OTransform',
        'msTransform'
      ];
      for (var i = 0; i < transformProps.length; i++) {
        var prop = transformProps[i];
        if (div.style[prop] !== undefined) {
          return prop;
        }
      }

      // return unprefixed version by default
      return transformProps[0];
    })();

    Polymer({
      is: 'things-gmap-scene-overlay',

      properties: {
        overlay: Object,
        context: Object,
        scene: Object,
        model: Object,
        map: Object,
        mode: {
          type: Number,
          value: 1
        },
        center: {
          type: Object,
          value: {
            lat: 39.3,
            lng: 55.8
          }
        },
        zoom: {
          type: Number,
          value: 2
        },
        resolutionScale: {
          type: Number,
          value: window.devicePixelRatio || 1
        },
        pane: {
          type: String,
          value: 'overlayMouseTarget'
        }
      },

      observers: [
        "_onSceneChanged(scene)"
      ],

      listeners: {
        "api.api-load": "_onApiLoad",
        "map.google-map-ready": "_onMapReady"
      },

      // Element Lifecycle

      ready: function() {
      },

      attached: function() {
      },

      detached: function() {
      },

      // Methods for Google Overlay inheritance

      _onApiLoad: function(e) {
        if(GmapSceneOverlay)
          return

        var overlay = function(){}

        var api = e.target.api

        overlay.prototype = new api.OverlayView()

        overlay.prototype.onAdd = this._onAdd.bind(this)
        overlay.prototype.onRemove = this._onRemove.bind(this)
        overlay.prototype.draw = this._draw.bind(this)

        GmapSceneOverlay = overlay
      },

      _onAdd: function() {
        if (this._isAdded)
          return;

        var panes = this.overlay.getPanes();
        if (!panes[this.pane])
          throw new Error('"' + this.pane + '" is not a valid MapPane name.');

        this.$.scene.disposeWhenDetached = false
        panes[this.pane].appendChild(this.$.scene);
        this.async(function() {
          // safari에서의 동작을 위해서, defered 시킴.
          this.$.scene.disposeWhenDetached = true
        }, 10)

        var self = this;

        var listener = function(e) {
          if(self.scene.mode() === 1)
            event.stopPropagation();
        };

        ['mousemove', 'dragstart', 'drag', 'dragend', 'dblclick', 'click', 'tap']
        .forEach(function(event) {
          google.maps.event.addDomListener(self.$.scene, event, listener)
        })

        // Handlers
        this._resizeListener = google.maps.event.addListener(this.map,
            'resize', this._resize.bind(this));
        this._centerListener = google.maps.event.addListener(this.map,
            'center_changed', this._reposition.bind(this));

        this._isAdded = true

        this._resize();
        this._reposition();
      },

      _onRemove: function() {
        if (!this._isAdded)
          return;

        this._isAdded = false;
        this._topLeft = null;

        // remove element and listeners for pan and resize from map
        this.$.scene.parentElement.removeChild(this.$.scene);

        if (this._centerListener) {
          google.maps.event.removeListener(this._centerListener);
          this._centerListener = null;
        }
        if (this._resizeListener) {
          google.maps.event.removeListener(this._resizeListener);
          this._resizeListener = null;
        }
      },

      _draw: function() {
        this._reposition();
      },

      _resize: function() {
        if (!this._isAdded)
          return;

        var mapWidth = this.map.getDiv().offsetWidth;
        var mapHeight = this.map.getDiv().offsetHeight;

        var newWidth = mapWidth * this.resolutionScale;
        var newHeight = mapHeight * this.resolutionScale;

        var oldWidth = this.$.scene.width;
        var oldHeight = this.$.scene.height;

        // resizing may allocate a new back buffer, so do so conservatively
        if (oldWidth !== newWidth || oldHeight !== newHeight) {
          this.$.scene.width = newWidth;
          this.$.scene.height = newHeight;

          this._needsResize = true;

          this.async(function() {
            this._update()
          }, 1)
        }

        // reset styling if new sizes don't match; resize of data not needed
        if (this._cssWidth !== mapWidth ||
            this._cssHeight !== mapHeight) {
          this._cssWidth = mapWidth;
          this._cssHeight = mapHeight;
          this.$.scene.style.width = mapWidth + 'px';
          this.$.scene.style.height = mapHeight + 'px';
        }
      },

      _reposition: function() {
        // TODO(bckenny): *should* only be executed on RAF, but in current browsers
        //     this causes noticeable hitches in map and overlay relative
        //     positioning.

        // topLeft can't be calculated from map.getBounds(), because bounds are
        // clamped to -180 and 180 when completely zoomed out. Instead, calculate
        // left as an offset from the center, which is an unwrapped LatLng.
        var top = this.map.getBounds().getNorthEast().lat();
        var center = this.map.getCenter();
        var scale = Math.pow(2, this.map.getZoom());
        var left = center.lng() - (this._cssWidth * 180) / (256 * scale);

        this._topLeft = new this.$.api.api.LatLng(top, left);

        // Canvas position relative to draggable map's container depends on
        // overlayView's projection, not the map's. Have to use the center of the
        // map for this, not the top left, for the same reason as above.
        // https://developers.google.com/maps/documentation/javascript/reference?hl=ko#MapCanvasProjection
        var projection = this.overlay.getProjection();

        var divCenter = projection.fromLatLngToDivPixel(center);
        var offsetX = -Math.round(this._cssWidth / 2 - divCenter.x);
        var offsetY = -Math.round(this._cssHeight / 2 - divCenter.y);

        this.$.scene.style[CSS_TRANSFORM] = 'translate(' +
            offsetX + 'px,' + offsetY + 'px)';

        this._update()
      },

      _update: function() {
        if(!this.scene)
          return

        if (this._needsResize) {
          this._needsResize = false;
          this.scene.resize();
        }

        // scale is just 2^zoom
        // If this.overlay is scaled (with resolutionScale), we need to scale by
        // the same amount to account for the larger canvas.
        var scale = Math.pow(2, this.map.zoom) * this.resolutionScale;
        this.scene.scale(scale, scale);
        /* If the map was not translated, the topLeft corner would be 0,0 in
         * world coordinates. Our translation is just the vector from the
         * world coordinate of the topLeft corder to 0,0.
         */

        var mapProjection = this.map.getProjection();

        var offset = mapProjection.fromLatLngToPoint(this._topLeft);
        this.scene.root().set('translate', {x: -offset.x * scale, y: -offset.y * scale});
      },

      // Element Behavior

      _onMapReady: function() {
        this._createOverlay()
      },

      _onSceneChanged: function(model) {
        this._createOverlay()
      },

      _createOverlay: function() {
        if(!GmapSceneOverlay || !this.scene || !this.map || this.overlay)
          return

        this.overlay = new GmapSceneOverlay()
        this.overlay.setMap(this.map)
      }

    });
  </script>
</dom-module>
